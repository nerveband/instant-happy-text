<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tidy Text - AI-Powered Note Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Helvetica Neue', Arial, sans-serif;
            background: #000;
            min-height: 100vh;
            padding: clamp(1rem, 3vw, 2rem);
            color: #000;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: #fff;
            border: 2px solid #000;
            padding: clamp(1.5rem, 4vw, 3rem);
            box-shadow: clamp(4px, 1vw, 8px) clamp(4px, 1vw, 8px) 0 rgba(0, 0, 0, 1);
        }

        h1 {
            font-size: clamp(1.75rem, 5vw, 2.5rem);
            margin-bottom: 0.5rem;
            color: #000;
            font-weight: 700;
            letter-spacing: -0.02em;
        }

        .subtitle {
            color: #666;
            margin-bottom: clamp(1rem, 3vw, 2rem);
            font-size: clamp(0.875rem, 2.5vw, 1rem);
            font-weight: 400;
        }

        .settings {
            display: grid;
            gap: clamp(0.75rem, 2vw, 1rem);
            margin-bottom: clamp(1rem, 3vw, 2rem);
            padding: clamp(1rem, 3vw, 2rem);
            background: #f5f5f5;
            border: 2px solid #000;
        }

        .setting-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        label {
            font-weight: 600;
            font-size: clamp(0.75rem, 2vw, 0.875rem);
            color: #000;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        input, textarea {
            padding: clamp(0.75rem, 2vw, 0.875rem);
            border: 2px solid #000;
            font-size: clamp(0.875rem, 2.5vw, 1rem);
            font-family: inherit;
            background: #fff;
            transition: all 0.15s ease;
            resize: vertical;
        }

        /* Custom Select Dropdown */
        .custom-select {
            position: relative;
            width: 100%;
        }

        .custom-select select {
            display: none;
        }

        .select-selected {
            background: #fff;
            border: 2px solid #000;
            padding: clamp(0.75rem, 2vw, 0.875rem);
            font-size: clamp(0.875rem, 2.5vw, 1rem);
            cursor: pointer;
            user-select: none;
            transition: all 0.15s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
        }

        .select-selected:after {
            content: 'â–¼';
            font-size: 0.75em;
            color: #000;
            transition: transform 0.15s ease;
        }

        .select-selected.select-arrow-active:after {
            transform: rotate(180deg);
        }

        .select-selected:hover {
            box-shadow: 2px 2px 0 rgba(0, 0, 0, 1);
            transform: translate(-1px, -1px);
        }

        .select-items {
            position: absolute;
            background: #fff;
            border: 2px solid #000;
            top: calc(100% + 4px);
            left: 0;
            right: 0;
            z-index: 99;
            max-height: 250px;
            overflow-y: auto;
            box-shadow: 4px 4px 0 rgba(0, 0, 0, 1);
        }

        .select-items div {
            padding: clamp(0.75rem, 2vw, 0.875rem);
            cursor: pointer;
            user-select: none;
            transition: all 0.1s ease;
            border-bottom: 1px solid #e0e0e0;
            font-size: clamp(0.875rem, 2.5vw, 1rem);
        }

        .select-items div:last-child {
            border-bottom: none;
        }

        .select-items div:hover {
            background: #000;
            color: #fff;
        }

        .select-hide {
            display: none;
        }

        select {
            padding: clamp(0.75rem, 2vw, 0.875rem);
            border: 2px solid #000;
            font-size: clamp(0.875rem, 2.5vw, 1rem);
            font-family: inherit;
            background: #fff;
            transition: all 0.15s ease;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            box-shadow: 4px 4px 0 rgba(0, 0, 0, 1);
            transform: translate(-2px, -2px);
        }

        input:hover, select:hover, textarea:hover {
            box-shadow: 2px 2px 0 rgba(0, 0, 0, 1);
            transform: translate(-1px, -1px);
        }

        .editor-wrapper {
            position: relative;
            margin-bottom: 1.5rem;
        }

        .editor-container {
            position: relative;
            background: #fff;
            border: 2px solid #000;
            transition: all 0.15s ease;
        }

        .editor-container:hover {
            box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
        }

        .editor-container:focus-within {
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 1);
        }

        .editor {
            width: 100%;
            min-height: clamp(300px, 60vh, 450px);
            padding: clamp(1rem, 3vw, 2rem);
            border: none;
            resize: vertical;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', 'Droid Sans Mono', monospace;
            font-size: clamp(0.9375rem, 2.5vw, 1.125rem);
            line-height: 1.8;
            background: transparent;
            color: #000;
        }

        @media (min-width: 768px) {
            .editor {
                line-height: 2;
            }
        }

        .editor:focus {
            outline: none;
        }

        .line-controls {
            position: fixed;
            display: none;
            gap: 0;
            background: #fff;
            border: 2px solid #000;
            z-index: 100;
        }

        .line-controls.active {
            display: flex;
        }

        .line-control-btn {
            width: 44px;
            height: 44px;
            border: none;
            border-right: 2px solid #000;
            background: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s ease;
            color: #000;
        }

        .line-control-btn:last-child {
            border-right: none;
        }

        .line-control-btn:hover {
            background: #000;
            color: #fff;
        }

        .line-control-btn:active {
            transform: scale(0.95);
        }

        .word-popup {
            position: fixed;
            background: #fff;
            border: 2px solid #000;
            padding: 0;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 1);
            z-index: 1000;
            display: none;
            min-width: 150px;
            max-width: 200px;
        }

        .word-popup.active {
            display: block;
        }

        .word-option {
            padding: 0.875rem 1rem;
            cursor: pointer;
            transition: all 0.1s ease;
            font-size: 1rem;
            border-bottom: 1px solid #e0e0e0;
        }

        .word-option:last-child {
            border-bottom: none;
        }

        .word-option:hover {
            background: #000;
            color: #fff;
        }

        .word-option.loading {
            color: #666;
            text-align: center;
        }

        .status {
            display: flex;
            align-items: center;
            gap: clamp(0.5rem, 2vw, 0.75rem);
            padding: clamp(1rem, 3vw, 1.25rem);
            background: #f5f5f5;
            border: 2px solid #000;
            font-size: clamp(0.8125rem, 2vw, 0.875rem);
            color: #000;
            font-weight: 500;
        }

        .status.processing {
            background: #fffacd;
        }

        .status.error {
            background: #ffcccb;
            color: #c00;
        }

        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #e0e0e0;
            border-top-color: #000;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-2px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .fade-in {
            animation: fadeIn 0.2s ease-out;
        }

        .hint {
            font-size: clamp(0.8125rem, 2vw, 0.875rem);
            color: #666;
            margin-top: clamp(1rem, 3vw, 1.5rem);
            line-height: 1.6;
        }

        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: clamp(0.5rem, 1.5vw, 0.75rem);
            margin-top: clamp(1rem, 3vw, 1.5rem);
            margin-bottom: clamp(1rem, 3vw, 1.5rem);
            padding: clamp(1rem, 3vw, 1.5rem);
            background: #f5f5f5;
            border: 2px solid #000;
        }

        @media (max-width: 480px) {
            .features {
                grid-template-columns: 1fr;
            }
        }

        .feature-toggle {
            display: flex;
            align-items: center;
            gap: clamp(0.5rem, 2vw, 0.75rem);
        }

        .feature-label {
            font-size: clamp(0.75rem, 2vw, 0.875rem);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #000;
            cursor: pointer;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 48px;
            height: 24px;
            flex-shrink: 0;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #fff;
            border: 2px solid #000;
            transition: 0.15s;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background: #000;
            transition: 0.15s;
        }

        input:checked + .slider {
            background: #000;
        }

        input:checked + .slider:before {
            background: #fff;
            transform: translateX(24px);
        }

        .credits {
            margin-top: clamp(1rem, 3vw, 2rem);
            padding-top: clamp(1rem, 3vw, 1.5rem);
            border-top: 2px solid #000;
            font-size: clamp(0.8125rem, 2vw, 0.875rem);
            color: #666;
            line-height: 1.6;
        }

        .credits a {
            color: #000;
            text-decoration: none;
            border-bottom: 2px solid #000;
            font-weight: 600;
        }

        .credits a:hover {
            background: #000;
            color: #fff;
        }

        /* Touch-friendly controls on mobile */
        @media (max-width: 768px) {
            .line-control-btn {
                width: 48px;
                height: 48px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Tidy Text</h1>
        <p class="subtitle">Sloppy notes that auto-correct, one line at a time</p>

        <div class="settings">
            <div class="setting-group">
                <label>Provider</label>
                <div class="custom-select">
                    <select id="provider">
                        <option value="gemini">Google Gemini</option>
                        <option value="cerebras">Cerebras</option>
                    </select>
                </div>
            </div>
            <div class="setting-group">
                <label>API Key</label>
                <input type="password" id="apiKey" value="" placeholder="Enter API key">
            </div>
            <div class="setting-group" id="modelGroup">
                <label>Model</label>
                <div class="custom-select">
                    <select id="model">
                        <option value="gemini-2.5-flash-lite">gemini-2.5-flash-lite (Fastest)</option>
                        <option value="gemini-2.5-flash">gemini-2.5-flash</option>
                    </select>
                </div>
            </div>
            <div class="setting-group">
                <label>Custom System Prompt (Optional)</label>
                <textarea id="customPrompt" placeholder="Add custom instructions for the AI (e.g., 'use British English', 'be more formal', 'add emoji')" rows="3"></textarea>
            </div>
        </div>

        <div class="features">
            <div class="feature-toggle">
                <label class="switch">
                    <input type="checkbox" id="autoCapitalize" checked>
                    <span class="slider"></span>
                </label>
                <label class="feature-label" for="autoCapitalize">Auto-capitalize</label>
            </div>
            <div class="feature-toggle">
                <label class="switch">
                    <input type="checkbox" id="fixPunctuation" checked>
                    <span class="slider"></span>
                </label>
                <label class="feature-label" for="fixPunctuation">Fix punctuation</label>
            </div>
            <div class="feature-toggle">
                <label class="switch">
                    <input type="checkbox" id="enableUndo" checked>
                    <span class="slider"></span>
                </label>
                <label class="feature-label" for="enableUndo">Undo/Redo</label>
            </div>
            <div class="feature-toggle">
                <label class="switch">
                    <input type="checkbox" id="wordSubstitutions" checked>
                    <span class="slider"></span>
                </label>
                <label class="feature-label" for="wordSubstitutions">Word substitutions</label>
            </div>
        </div>

        <div class="editor-wrapper">
            <div class="editor-container">
                <textarea
                    id="editor"
                    class="editor"
                    placeholder="Type in lowercase. Press Enter to auto-correct the previous line.
Try it:
- just type without punctuation or caps
- tomorrow 6:30pm at the park
- 300g flour 150ml water 10g salt"
                    spellcheck="false"
                ></textarea>
            </div>
            <div id="lineControls" class="line-controls">
                <button class="line-control-btn" id="undoBtn" title="Undo (restore original)">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 7v6h6"/>
                        <path d="M21 17a9 9 0 00-9-9 9 9 0 00-6 2.3L3 13"/>
                    </svg>
                </button>
                <button class="line-control-btn" id="regenBtn" title="Regenerate">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0118.8-4.3M22 12.5a10 10 0 01-18.8 4.2"/>
                    </svg>
                </button>
            </div>
        </div>

        <div id="wordPopup" class="word-popup">
            <div class="word-option loading">Loading alternatives...</div>
        </div>

        <div id="status" class="status">
            Ready. Type and press Enter to auto-correct.
        </div>

        <div class="hint">
            <strong>Tips:</strong> Press Enter after a line to auto-correct it.
            Hover over any line to see undo/regen buttons.
            Click any word to see AI-powered alternatives.
        </div>

        <div class="credits">
            Remixed by <a href="https://ashrafali.net" target="_blank">Ashraf Ali</a>
            <br>
            Forked and inspired by <a href="https://blog.florianschulz.info/2025/10/tidy-text-sloppy-notes/" target="_blank">Florian Schulz's Tidy Text</a>
        </div>
    </div>

    <script type="module">
        import { GoogleGenAI } from 'https://esm.run/@google/genai';

        // Initialize custom dropdowns
        function initCustomSelects() {
            const customSelects = document.querySelectorAll('.custom-select');

            customSelects.forEach(customSelect => {
                const select = customSelect.querySelector('select');
                const selected = document.createElement('div');
                selected.className = 'select-selected';
                selected.textContent = select.options[select.selectedIndex].text;
                customSelect.appendChild(selected);

                const items = document.createElement('div');
                items.className = 'select-items select-hide';

                Array.from(select.options).forEach((option, index) => {
                    const item = document.createElement('div');
                    item.textContent = option.text;
                    item.dataset.value = option.value;

                    item.addEventListener('click', function(e) {
                        e.stopPropagation();
                        select.selectedIndex = index;
                        selected.textContent = this.textContent;

                        // Trigger change event on the original select
                        const event = new Event('change', { bubbles: true });
                        select.dispatchEvent(event);

                        // Close dropdown
                        items.classList.add('select-hide');
                        selected.classList.remove('select-arrow-active');
                    });

                    items.appendChild(item);
                });

                customSelect.appendChild(items);

                // Toggle dropdown
                selected.addEventListener('click', function(e) {
                    e.stopPropagation();
                    closeAllSelect(this);
                    this.classList.toggle('select-arrow-active');
                    items.classList.toggle('select-hide');
                });
            });

            // Close dropdowns when clicking outside
            document.addEventListener('click', closeAllSelect);

            function closeAllSelect(element) {
                const items = document.querySelectorAll('.select-items');
                const selected = document.querySelectorAll('.select-selected');

                items.forEach((item, index) => {
                    if (element !== selected[index]) {
                        item.classList.add('select-hide');
                        selected[index].classList.remove('select-arrow-active');
                    }
                });
            }
        }

        // Initialize on load
        initCustomSelects();

        const editor = document.getElementById('editor');
        const apiKeyInput = document.getElementById('apiKey');
        const providerSelect = document.getElementById('provider');
        const modelSelect = document.getElementById('model');
        const modelGroup = document.getElementById('modelGroup');
        const customPromptInput = document.getElementById('customPrompt');
        const lineControls = document.getElementById('lineControls');
        const undoBtn = document.getElementById('undoBtn');
        const regenBtn = document.getElementById('regenBtn');
        const wordPopup = document.getElementById('wordPopup');
        const statusEl = document.getElementById('status');

        // Feature toggles
        const autoCapitalizeToggle = document.getElementById('autoCapitalize');
        const fixPunctuationToggle = document.getElementById('fixPunctuation');
        const enableUndoToggle = document.getElementById('enableUndo');
        const wordSubstitutionsToggle = document.getElementById('wordSubstitutions');

        let isProcessing = false;
        let lineHistory = new Map(); // lineIndex -> {original, corrected}
        let correctedLines = new Set(); // Track which lines have been corrected
        let currentHoverLine = null;
        let selectedWord = null;

        // Load saved settings
        const savedKey = localStorage.getItem('TIDY_TEXT_API_KEY');
        const savedProvider = localStorage.getItem('TIDY_TEXT_PROVIDER');
        const savedCustomPrompt = localStorage.getItem('TIDY_TEXT_CUSTOM_PROMPT');
        if (savedKey) apiKeyInput.value = savedKey;
        if (savedProvider) providerSelect.value = savedProvider;
        if (savedCustomPrompt) customPromptInput.value = savedCustomPrompt;

        // Load feature toggle states
        const savedAutoCapitalize = localStorage.getItem('TIDY_TEXT_AUTO_CAPITALIZE');
        const savedFixPunctuation = localStorage.getItem('TIDY_TEXT_FIX_PUNCTUATION');
        const savedEnableUndo = localStorage.getItem('TIDY_TEXT_ENABLE_UNDO');
        const savedWordSubstitutions = localStorage.getItem('TIDY_TEXT_WORD_SUBSTITUTIONS');

        if (savedAutoCapitalize !== null) autoCapitalizeToggle.checked = savedAutoCapitalize === 'true';
        if (savedFixPunctuation !== null) fixPunctuationToggle.checked = savedFixPunctuation === 'true';
        if (savedEnableUndo !== null) enableUndoToggle.checked = savedEnableUndo === 'true';
        if (savedWordSubstitutions !== null) wordSubstitutionsToggle.checked = savedWordSubstitutions === 'true';

        // Save settings to localStorage
        apiKeyInput.addEventListener('change', () => {
            localStorage.setItem('TIDY_TEXT_API_KEY', apiKeyInput.value);
        });

        providerSelect.addEventListener('change', () => {
            localStorage.setItem('TIDY_TEXT_PROVIDER', providerSelect.value);
            updateProviderUI();
        });

        // Save feature toggle states
        autoCapitalizeToggle.addEventListener('change', () => {
            localStorage.setItem('TIDY_TEXT_AUTO_CAPITALIZE', autoCapitalizeToggle.checked);
        });

        fixPunctuationToggle.addEventListener('change', () => {
            localStorage.setItem('TIDY_TEXT_FIX_PUNCTUATION', fixPunctuationToggle.checked);
        });

        enableUndoToggle.addEventListener('change', () => {
            localStorage.setItem('TIDY_TEXT_ENABLE_UNDO', enableUndoToggle.checked);
            updateUndoVisibility();
        });

        wordSubstitutionsToggle.addEventListener('change', () => {
            localStorage.setItem('TIDY_TEXT_WORD_SUBSTITUTIONS', wordSubstitutionsToggle.checked);
        });

        customPromptInput.addEventListener('change', () => {
            localStorage.setItem('TIDY_TEXT_CUSTOM_PROMPT', customPromptInput.value);
        });

        // Update UI based on provider
        function updateProviderUI() {
            const provider = providerSelect.value;
            if (provider === 'cerebras') {
                modelGroup.style.display = 'none';
                apiKeyInput.placeholder = 'Enter Cerebras API key';
            } else {
                modelGroup.style.display = 'flex';
                apiKeyInput.placeholder = 'Enter Google AI Studio API key';
            }

            // Update custom select display
            const providerCustomSelect = providerSelect.closest('.custom-select');
            if (providerCustomSelect) {
                const selected = providerCustomSelect.querySelector('.select-selected');
                if (selected) {
                    selected.textContent = providerSelect.options[providerSelect.selectedIndex].text;
                }
            }
        }

        function updateUndoVisibility() {
            if (!enableUndoToggle.checked) {
                lineControls.classList.remove('active');
            }
        }

        updateProviderUI();
        updateUndoVisibility();

        function setStatus(message, type = 'info') {
            statusEl.textContent = message;
            statusEl.className = 'status';
            if (type === 'processing') {
                statusEl.className = 'status processing';
                statusEl.innerHTML = '<div class="spinner"></div>' + message;
            } else if (type === 'error') {
                statusEl.className = 'status error';
            }
        }

        function getCaretInfo() {
            return {
                start: editor.selectionStart,
                end: editor.selectionEnd
            };
        }

        function setCaret(start, end) {
            editor.focus();
            editor.setSelectionRange(start, end);
        }

        function getLineIndexAtPosition(text, pos) {
            return text.slice(0, pos).split('\n').length - 1;
        }

        function getLineBounds(text, lineIndex) {
            const lines = text.split('\n');
            let start = 0;
            for (let i = 0; i < lineIndex; i++) {
                start += lines[i].length + 1;
            }
            const end = start + lines[lineIndex].length;
            return { start, end };
        }

        function getLineAtCaret() {
            const { start } = getCaretInfo();
            const lineIndex = getLineIndexAtPosition(editor.value, start);
            const { start: lineStart, end: lineEnd } = getLineBounds(editor.value, lineIndex);
            return {
                lineIndex,
                start: lineStart,
                end: lineEnd,
                text: editor.value.slice(lineStart, lineEnd)
            };
        }

        async function correctText(text) {
            const apiKey = apiKeyInput.value.trim();
            if (!apiKey) {
                throw new Error('Please enter an API key');
            }

            const provider = providerSelect.value;

            if (provider === 'cerebras') {
                return await correctTextCerebras(text, apiKey);
            } else {
                return await correctTextGemini(text, apiKey);
            }
        }

        async function correctTextGemini(text, apiKey) {
            const ai = new GoogleGenAI({ apiKey });
            const model = modelSelect.value;

            let instructions = [];
            if (fixPunctuationToggle.checked) instructions.push('fix punctuation');
            if (autoCapitalizeToggle.checked) instructions.push('fix capitalization');
            instructions.push('fix spelling');

            let systemInstruction = `You are a text formatter. You ONLY fix formatting issues in text: ${instructions.join(', ')}. Do NOT answer questions, do NOT add new content, do NOT change the meaning. If the user writes "what is 2+2", return "What is 2+2?" - never answer it. Only fix the formatting, spelling, and presentation of the exact text provided.`;

            const customPrompt = customPromptInput.value.trim();
            if (customPrompt) {
                systemInstruction += ` Additional formatting rules: ${customPrompt}`;
            }

            const response = await ai.models.generateContent({
                model,
                contents: text,
                config: { systemInstruction }
            });

            return response.text;
        }

        async function correctTextCerebras(text, apiKey) {
            let instructions = [];
            if (fixPunctuationToggle.checked) instructions.push('fix punctuation');
            if (autoCapitalizeToggle.checked) instructions.push('fix capitalization');
            instructions.push('fix spelling');

            let systemInstruction = `You are a text formatter. You ONLY fix formatting issues in text: ${instructions.join(', ')}. Do NOT answer questions, do NOT add new content, do NOT change the meaning. If the user writes "what is 2+2", return "What is 2+2?" - never answer it. Only fix the formatting, spelling, and presentation of the exact text provided.`;

            const customPrompt = customPromptInput.value.trim();
            if (customPrompt) {
                systemInstruction += ` Additional formatting rules: ${customPrompt}`;
            }

            const response = await fetch('https://api.cerebras.ai/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: 'qwen-3-235b-a22b-instruct-2507',
                    messages: [
                        {
                            role: 'system',
                            content: systemInstruction
                        },
                        {
                            role: 'user',
                            content: text
                        }
                    ],
                    temperature: 0.7,
                    max_completion_tokens: 1000
                })
            });

            if (!response.ok) {
                const error = await response.text();
                throw new Error(`Cerebras API error: ${error}`);
            }

            const data = await response.json();
            return data.choices[0].message.content;
        }

        async function getWordAlternatives(word, sentence) {
            const apiKey = apiKeyInput.value.trim();
            if (!apiKey) return [];

            const provider = providerSelect.value;

            try {
                if (provider === 'cerebras') {
                    return await getWordAlternativesCerebras(word, sentence, apiKey);
                } else {
                    return await getWordAlternativesGemini(word, sentence, apiKey);
                }
            } catch (e) {
                console.error('Error getting word alternatives:', e);
                return [];
            }
        }

        async function getWordAlternativesGemini(word, sentence, apiKey) {
            const ai = new GoogleGenAI({ apiKey });
            const model = modelSelect.value;

            const systemInstruction = `You are a thesaurus and word suggestion tool. Given a word and its sentence context, provide 3-5 contextually appropriate alternative words or phrases. Return only a JSON array of strings, nothing else.`;

            const response = await ai.models.generateContent({
                model,
                contents: `Word: "${word}"\nSentence: "${sentence}"\n\nProvide alternatives as JSON array.`,
                config: {
                    systemInstruction,
                    responseMimeType: 'application/json'
                }
            });

            const alternatives = JSON.parse(response.text);
            return Array.isArray(alternatives) ? alternatives : [];
        }

        async function getWordAlternativesCerebras(word, sentence, apiKey) {
            const response = await fetch('https://api.cerebras.ai/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: 'qwen-3-235b-a22b-instruct-2507',
                    messages: [
                        {
                            role: 'system',
                            content: 'You are a thesaurus and word suggestion tool. Given a word and its sentence context, provide 3-5 contextually appropriate alternative words or phrases. Return only a JSON array of strings, nothing else.'
                        },
                        {
                            role: 'user',
                            content: `Word: "${word}"\nSentence: "${sentence}"\n\nProvide alternatives as JSON array.`
                        }
                    ],
                    temperature: 0.7,
                    max_completion_tokens: 200
                })
            });

            if (!response.ok) return [];

            const data = await response.json();
            const alternatives = JSON.parse(data.choices[0].message.content);
            return Array.isArray(alternatives) ? alternatives : [];
        }

        async function processLine(lineIndex, lineStart, lineEnd, originalText) {
            if (isProcessing) return;

            // Check if any correction features are enabled
            if (!autoCapitalizeToggle.checked && !fixPunctuationToggle.checked) {
                return;
            }

            isProcessing = true;
            setStatus('Correcting...', 'processing');

            try {
                const correctedText = await correctText(originalText);

                // Store history if undo is enabled
                if (enableUndoToggle.checked && !lineHistory.has(lineIndex)) {
                    lineHistory.set(lineIndex, { original: originalText, corrected: correctedText });
                }

                // Mark line as corrected
                correctedLines.add(lineIndex);

                // Replace text with animation
                const newValue =
                    editor.value.slice(0, lineStart) +
                    correctedText +
                    editor.value.slice(lineEnd);

                editor.value = newValue;
                editor.classList.add('fade-in');
                setTimeout(() => editor.classList.remove('fade-in'), 300);

                // Restore caret position
                const delta = correctedText.length - originalText.length;
                const { start: caretStart, end: caretEnd } = getCaretInfo();
                if (caretStart >= lineEnd) {
                    setCaret(caretStart + delta, caretEnd + delta);
                } else {
                    setCaret(caretStart, caretEnd);
                }

                setStatus('Corrected');
            } catch (error) {
                setStatus('Error: ' + error.message, 'error');
            } finally {
                isProcessing = false;
            }
        }

        // Handle Enter key
        editor.addEventListener('keydown', async (e) => {
            if (e.key !== 'Enter') return;

            const { start } = getCaretInfo();
            const lineIndex = getLineIndexAtPosition(editor.value, start);

            if (lineIndex < 0) return;

            setTimeout(() => {
                const { start: lineStart, end: lineEnd } = getLineBounds(editor.value, lineIndex);
                const lineText = editor.value.slice(lineStart, lineEnd).trim();

                if (lineText) {
                    processLine(lineIndex, lineStart, lineEnd, lineText);
                }
            }, 0);
        });

        // Line hover controls - improved detection
        let hoverTimeout;

        function getLineAtMousePosition(e) {
            const rect = editor.getBoundingClientRect();
            const lineHeight = parseInt(getComputedStyle(editor).lineHeight);
            const scrollTop = editor.scrollTop;
            const paddingTop = parseInt(getComputedStyle(editor).paddingTop);

            // Calculate which line the mouse is over
            const relativeY = e.clientY - rect.top + scrollTop - paddingTop;
            const lineIndex = Math.floor(relativeY / lineHeight);

            const lines = editor.value.split('\n');
            if (lineIndex >= 0 && lineIndex < lines.length) {
                let start = 0;
                for (let i = 0; i < lineIndex; i++) {
                    start += lines[i].length + 1;
                }
                const end = start + lines[lineIndex].length;

                return {
                    lineIndex,
                    start,
                    end,
                    text: lines[lineIndex]
                };
            }
            return null;
        }

        editor.addEventListener('mousemove', (e) => {
            if (!enableUndoToggle.checked) return;

            clearTimeout(hoverTimeout);

            const line = getLineAtMousePosition(e);

            // Only show controls for lines that have been corrected
            if (line && line.text.trim() && correctedLines.has(line.lineIndex)) {
                currentHoverLine = line;
                const rect = editor.getBoundingClientRect();
                const lineHeight = parseInt(getComputedStyle(editor).lineHeight);
                const paddingTop = parseInt(getComputedStyle(editor).paddingTop);
                const paddingLeft = parseInt(getComputedStyle(editor).paddingLeft);

                // Create a more accurate measurement canvas
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                const computedStyle = getComputedStyle(editor);
                context.font = computedStyle.font;
                const metrics = context.measureText(line.text);
                const textWidth = metrics.width;

                const top = rect.top + (line.lineIndex * lineHeight) + paddingTop + (lineHeight / 2) - 22 + window.scrollY;
                const left = rect.left + paddingLeft + textWidth + 12;

                lineControls.style.top = top + 'px';
                lineControls.style.left = left + 'px';
                lineControls.classList.add('active');
            } else {
                hoverTimeout = setTimeout(() => {
                    if (!lineControls.matches(':hover')) {
                        lineControls.classList.remove('active');
                        currentHoverLine = null;
                    }
                }, 100);
            }
        });

        editor.addEventListener('mouseleave', () => {
            clearTimeout(hoverTimeout);
            hoverTimeout = setTimeout(() => {
                if (!lineControls.matches(':hover')) {
                    lineControls.classList.remove('active');
                    currentHoverLine = null;
                }
            }, 100);
        });

        lineControls.addEventListener('mouseenter', () => {
            clearTimeout(hoverTimeout);
            lineControls.classList.add('active');
        });

        lineControls.addEventListener('mouseleave', () => {
            lineControls.classList.remove('active');
            currentHoverLine = null;
        });

        // Undo button
        undoBtn.addEventListener('click', () => {
            if (!currentHoverLine) return;

            const history = lineHistory.get(currentHoverLine.lineIndex);
            if (history && history.original) {
                const newValue =
                    editor.value.slice(0, currentHoverLine.start) +
                    history.original +
                    editor.value.slice(currentHoverLine.end);

                editor.value = newValue;
                editor.classList.add('fade-in');
                setTimeout(() => editor.classList.remove('fade-in'), 300);

                lineHistory.delete(currentHoverLine.lineIndex);
                correctedLines.delete(currentHoverLine.lineIndex);
                lineControls.classList.remove('active');
                setStatus('Restored original');
            }
        });

        // Regen button
        regenBtn.addEventListener('click', async () => {
            if (!currentHoverLine) return;

            await processLine(
                currentHoverLine.lineIndex,
                currentHoverLine.start,
                currentHoverLine.end,
                currentHoverLine.text
            );
        });

        // Word hover for alternatives
        let wordHoverTimeout;
        editor.addEventListener('click', async (e) => {
            if (!wordSubstitutionsToggle.checked) {
                wordPopup.classList.remove('active');
                return;
            }

            const pos = editor.selectionStart;
            const text = editor.value;

            // Find word boundaries
            let start = pos;
            let end = pos;

            while (start > 0 && /\w/.test(text[start - 1])) start--;
            while (end < text.length && /\w/.test(text[end])) end++;

            const word = text.slice(start, end).trim();
            if (!word || word.length < 2) {
                wordPopup.classList.remove('active');
                return;
            }

            selectedWord = { word, start, end };

            // Get line for context
            const lineIndex = getLineIndexAtPosition(text, pos);
            const { start: lineStart, end: lineEnd } = getLineBounds(text, lineIndex);
            const sentence = text.slice(lineStart, lineEnd);

            // Calculate position more accurately
            const rect = editor.getBoundingClientRect();
            const lineHeight = parseInt(getComputedStyle(editor).lineHeight);
            const paddingTop = parseInt(getComputedStyle(editor).paddingTop);
            const paddingLeft = parseInt(getComputedStyle(editor).paddingLeft);

            // Get text up to the clicked position on this line
            const textBeforeWord = text.slice(lineStart, start);

            // Measure text width using canvas for accuracy
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const computedStyle = getComputedStyle(editor);
            context.font = computedStyle.font;
            const textWidthBeforeWord = context.measureText(textBeforeWord).width;
            const wordWidth = context.measureText(word).width;

            const popupLeft = rect.left + paddingLeft + textWidthBeforeWord + (wordWidth / 2) - 75; // Center under word (150px wide / 2)
            const popupTop = rect.top + paddingTop + (lineIndex * lineHeight) + lineHeight + 8 + window.scrollY;

            wordPopup.style.left = popupLeft + 'px';
            wordPopup.style.top = popupTop + 'px';
            wordPopup.classList.add('active');
            wordPopup.innerHTML = '<div class="word-option loading">Loading alternatives...</div>';

            // Get alternatives
            const alternatives = await getWordAlternatives(word, sentence);

            if (alternatives.length > 0) {
                wordPopup.innerHTML = alternatives
                    .slice(0, 5)
                    .map(alt => `<div class="word-option" data-word="${alt}">${alt}</div>`)
                    .join('');

                // Add click handlers
                wordPopup.querySelectorAll('.word-option').forEach(option => {
                    option.addEventListener('click', () => {
                        const newWord = option.dataset.word;
                        if (selectedWord) {
                            const newValue =
                                editor.value.slice(0, selectedWord.start) +
                                newWord +
                                editor.value.slice(selectedWord.end);

                            editor.value = newValue;
                            editor.classList.add('fade-in');
                            setTimeout(() => editor.classList.remove('fade-in'), 300);

                            setCaret(selectedWord.start + newWord.length, selectedWord.start + newWord.length);
                        }
                        wordPopup.classList.remove('active');
                    });
                });
            } else {
                wordPopup.innerHTML = '<div class="word-option loading">No alternatives found</div>';
            }
        });

        // Close word popup when clicking outside
        document.addEventListener('click', (e) => {
            if (!wordPopup.contains(e.target) && e.target !== editor) {
                wordPopup.classList.remove('active');
            }
        });

        // Helper function to get caret coordinates
        function getCaretCoordinates(element, position) {
            const div = document.createElement('div');
            const span = document.createElement('span');
            const style = getComputedStyle(element);

            div.style.position = 'absolute';
            div.style.visibility = 'hidden';
            div.style.whiteSpace = 'pre-wrap';
            div.style.font = style.font;
            div.style.lineHeight = style.lineHeight;
            div.style.padding = style.padding;

            div.textContent = element.value.slice(0, position);
            span.textContent = element.value.slice(position) || '.';
            div.appendChild(span);
            document.body.appendChild(div);

            const { offsetLeft, offsetTop } = span;
            document.body.removeChild(div);

            return { left: offsetLeft, top: offsetTop };
        }
    </script>
</body>
</html>
